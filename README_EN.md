# Quicker
A simple, lightweight, distributed full-text indexing framework

## Inverted Index

<img src="demo/views/img/倒排索引.png" width="500"/>    

- The list in the inverted index is ordered, facilitating the quick intersection of multiple inverted lists.
- DocId is an auto-incrementing ID generated by the Quicker system for the doc, used for sorting in the SkipList.
- Id is the ID of the doc on the business side.
- BitsFeature is a uint64 that encodes the attributes of the doc into a bit stream, enabling partial filtering while traversing the inverted index.

## Forward Index
Currently, only the badger and bolt databases are supported for storing the details of the doc.

## Distributed Index
The index servers communicate with each other through grpc, and service registration and discovery are implemented through etcd.

## Usage
`go get -u github.com/hjrbill/quicker`

## Quickstart
### Assuming the business doc is Book
```go 
type Book struct {
	ISBN    string
	Title   string
	Author  string
	Price   float64
	Content string
}
// The business side implements the serialization and deserialization of the doc on its own
func (book *Book) Serialize() []byte {
    // Implement the serialization logic here
}
func DeserializeBook(v []byte) *Book {
    // Implement the deserialization logic here
}
```
### Initializing Quicker
```go
dbType := kvdb.BADGER   // Or kvdb.BOLT
dbPath := "data/local_db/book_badger"   // Storage path for the forward index
docNum := 10000    // Estimated number of documents to be stored in the index
quicker := new(index_service.Indexer)
if err := quicker.Init(docNum, dbType, dbPath); err != nil {
    panic(err)
}
defer quicker.Close()
```
### Adding a doc
```go
book := Book{}
doc := types.Document{
		Id:          book.ISBN,
		BitsFeature: 0b10011, // Binary
		Keywords:    []*types.Keyword{{Field: "content", Word: "Tang Dynasty"}, {Field: "content", Word: "cultural relics"}, {Field: "title", Word: book.Title}},
		Bytes:       book.Serialize(),
	}
quicker.AddDoc(doc)
```
### Deleting a doc
```go 
quicker.DeleteDoc(doc.Id)
```
### Searching
```go 
q1 := types.NewTermQuery("title", "Origin of Life")
q2 := types.NewTermQuery("content", "cultural relics")
q3 := types.NewTermQuery("title", "Chinese History")
q4 := types.NewTermQuery("content", "cultural relics")
q5 := types.NewTermQuery("content", "Tang Dynasty")

// Supports arbitrary complex combinations of And and Or. And requires all terms to match, while Or requires at least one term to match
query := (q1.Or(q2)).And((q3.Or(q4)).And(q5)
var onFlag uint64 = 0b10000    // The corresponding bits in doc.BitsFeature must all be 1
var offFlag uint64 = 0b01000    // The corresponding bits in doc.BitsFeature must all be 0
orFlags := []uint64{uint64(0b00010), uint64(0b00101)}    // At least one of the corresponding bits in doc.BitsFeature must be 1
docs := quicker.Search(query, onFlag, offFlag, orFlags) // Search
for _, doc := range docs {
    book := DeserializeBook(doc.Bytes) // The search result is a binary stream, which needs to be deserialized
    // Perform further processing on the retrieved book object
}
```

Note: The code snippet for deserializing the book object is incomplete in the provided text. You would need to implement the `DeserializeBook` function to convert the binary data back into a `Book` struct.